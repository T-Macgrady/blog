# 浏览器渲染原理和js运行机制

## 进程与线程

- 浏览器是多进程的，每打开一个 tab 页，就相当于创建了一个独立的浏览器进程。
- 浏览器包含的进程：

  - Browser 进程：浏览器的主进程（负责协调，主控），只有一个，作用有：

    - 负责浏览器的界面显示，与用户交互，如前进，后退等
    - 负责各个页面的管理，创建和销毁其它进程
    - 将 Rendered 进程得到的内存中的 Bitmap,绘制到用户界面上
    - 网络资源的管理，下载

  - 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。
  - GPU 进程：最多一个，用于 3D 绘制等。
  - 浏览器渲染进程（浏览器内核）（Render 进程，内部是多线程的）：默认每个 Tab 页面一个进程，互不影响。主要作用为：

    - 页面渲染，脚本执行，事件处理等

## 浏览器内核（渲染进程）

浏览器是多进程的，浏览器的渲染进程是多线程的；

- GUI 渲染线程：负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
- JS 引擎线程：处理 JavaScript 脚本程序，如 V8 引擎，解析和运行代码。
- 事件触发线程：控制事件循环，处理 JS 引擎和浏览器的交互事件。
- 定时触发器线程：处理定时任务，如 setTimeout 和 setInterval。
- 异步 HTTP 请求线程：处理异步的 HTTP 请求，将状态变更事件添加到事件队列中。

<img src="https://segmentfault.com/img/bV6ZLo/view?w=655&h=608" />

Browser 主进程和浏览器内核（渲染进程）的通信过程
<img src="https://segmentfault.com/img/bV66KM?w=1034&h=560" />

## 浏览器内核（渲染进程）中线程之间的关系

### GUI 渲染线程与 JS 引擎线程互斥

- 确保在修改 DOM 元素属性并同时渲染界面时不出现不一致的情况。当 JS 引擎执行时，GUI 线程会被挂起，GUI 更新会保存在队列中，待 JS 引擎空闲时立即执行。

- JS 阻塞页面加载

如果 JS 引擎进行大量计算，即使 GUI 有更新，也会等待 JS 引擎空闲后才能执行。这会导致页面渲染不连贯，给用户一种加载阻塞的感觉。因此，应尽量避免 JS 执行时间过长，以提高页面渲染的流畅性

- css 加载是否会阻塞 dom 树渲染

css 加载不会阻塞 DOM 树解析（异步加载时 dom 照常构建）
但会阻塞 render 树渲染（渲染时需要等 css 加载完毕，因为 render 树需要 css 信息）, 是为了避免在 CSS 加载期间修改 DOM 节点的样式导致不必要的重绘或回流

## 总结浏览器渲染流程

- 输入 url,浏览器主进程接管，开一个下载线程，进行 http 请求(略去 DNS 查询，IP 寻址等等操作),获取内容。
- 将内容通过 RendererHost 接口转交给 Render 进程。
- 浏览器内核拿到内容后，渲染大概可以划分为：
  - 解析 html 建立 dom
  - 解析 css 构建 render 树(将 css 代码解析成树形的数据结构，然后结合 dom 合并成 render 树)
  - 布局 render 树(Layout/reflow),负责各元素尺寸，位置的计算
  - 绘制 render 树(paint),绘制页面像素信息
  - 将各层的信息发送给 GPU,GPU 会将各层合成(composite),显示在屏幕上。
- 渲染完毕后，触发 load 事件，之后是自己的 JS 逻辑处理。

## 普通图层和复合图层

普通图层和复合图层是浏览器渲染过程中常见的两个概念。

- 普通图层是包含多个元素的整体，而复合图层则是由普通图层中的元素组成的一种图层类型。
- 使用硬件加速技术可以声明一个新的复合图层，从而独立分配资源并避免普通文档流中的回流重绘。
- 在硬件加速时，请使用 index 属性来防止浏览器默认为后续的元素创建复合层渲染。
- 开启硬件加速后，一个元素会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，但尽量不要大量使用复合图层，否则由于资源消耗过度，页面可能会变的更卡。

## 从 Event Loop 谈 JS 的运行机制

到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS 引擎的一些运行机制分析。主要是结合 Event Loop 来谈 JS 代码是如何执行的。
我们已经知道了 JS 引擎是单线程的，知道了 JS 引擎线程，事件触发线程，定时触发器线程。
然后还需要知道：

### JS 分为同步任务和异步任务

<img src="https://segmentfault.com/img/bV6WyG?w=716&h=506" />

- 同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件
- 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。

<img src="https://segmentfault.com/img/bV6WOP?w=703&h=509" />

主线程在运行时会产生执行栈，栈中的代码调用某些 api 时，它们会在事件队列中添加各种事件（当满足触发条件后，如 ajax 请求完毕）。而当栈中的代码执行完毕，就会去读取事件队列中的事件，去执行那些回调，如此循环。

### 宏任务和微任务
异步任务分为宏任务和微任务

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

<img src="https://segmentfault.com/img/bV6YSS?w=506&h=570" />

